
- Mise en place MVVM (http://martinfowler.com/eaaDev/PresentationModel.html)
  - ok : binding de base
  - manque les props avancées : visible, enabled...

- Guava EventBus pour la navigation
  - ok : navigation explicite depuis un modele de vue
  - ok : evts applicatifs (sommaire...)

- Sécurité : intégration de Apache Chiro :
  http://shiro.apache.org/authentication-features.html
  - ok : intégration avec JPA
  - intégration avec un serveur LDAP à faire

UI :
- ok : ne pas utiliser un Navigator, mais faire la navigation a la main
- ok : découverte auto des classes "View" par Spring
- ok : gestion de la navigation par evt
- ok : shiro reste utilisé, mais indirectement (a la main sans passer par le ShiroNavigator)

*** Repository ***
- normalement les echanges avec le repo se font uniquement avec des objets métiers
- il doit doit donc faire la conversion en interne avec les types d'objets persistés
- attention : dans CQRS, le repo fait partie de la partie 'lecture' de l'application et ne manipule donc pas des objets métiers

*** Event Sourcing ***
Generation des evts :
- execution d'une commande (un service adapter) :
  - récuperation de l'agregat concerné (normalement 1 seul doit etre modifié par la commande)
  - appel à la méthode métier sur l'agregat
  - cette méthode ne modifie pas directement l'etat de l'agregat, mais retourne une liste d'evts qui chacun décrivent une modification "métier"
  - cette liste d'evts est ensuite passée à l'eventStore qui se charge de :
    - appliquer les evts sur l'agregat
    - stocket les evts
    - propager les evts aux listeners

*** CQRS ***
- l'application est coupée en 2 parties :
  - commandes : méthodes qui modifient l'état de l'appli
    - service applicatif dédié
    - objets metier
    - eventStore
  - queries : requetes en consultation
    - service applicatif dédié
    - le service effectue les conversions entre les types "evt" et ceux du service (les utilisateurs du service
      doivent ne voir que des types de le couche "evt"
    - repo dédié
    - manipule des pojos
    - ecoute l'eventStore pour se maintenir a jour

 __TODO__ :

URGENT :
 - ? créer des classes commande. Les mettre en tant que classes statiques dans le service ? (pour les retrouver facilement)
 - gestion des evts dans l'ihm : lors de la modif d'un objet, la ligne du tableau
   correspondante doit se mettre à jour
   - attention : comment lier le bus global à chaque instance de vue ?
 - persistence du EventStore

 - A l'init de la session utilisateur, un bus dédié à l'utilisateur est créé
 - les vues de ce user s'enregistrent sur ce bus
 - ce bus écoute et forwarde les evts envoyés sur le bus principal
 => Il faut activer le scope session de Spring pour :
   - injection directe dans les vues du bus
   - init du bus a la creation de la session (enregistrement aupres du bus principal)
   - le plus sur est peut etre de ne pas enregistrer les bus locaux sur le bus principal
     mais de passer par un intermédiaire (pour eviter les leaks)
     Dans ce cas les bus locaux doivent tous etre enregistrés dans une map

 (((
 - notification de la vue par le modele de vue :
   - le modele de vue peut ecouter les evts applicatifs et reagir
   - la vue associée doit se mettre à jour
   - ex : suppression d'une ligne dans un tableau en cours d'affichage : la ligne disparait automatiquement
 )))

 - TU Binding : il reste a controler le binding dans les tables

 - menu de navigation entre les vues :
   * propose les vues découvertes (plugins)
   - affiche un icone et un nom pour chaque vue
   - gestion des droits d'acces (acces au plugin en fonction de roles)

 - chaque module/ecran(?) doit contenir son fichier de langue

 (- intégration LDAP)

 - module d'edition des Patients

 - mise en place CQRS + event sourcing
   http://www.jayway.com/2013/03/08/aggregates-event-sourcing-distilled/
   http://www.jayway.com/2013/06/20/dont-publish-domain-events-return-them/

 - module technique qui log les actions :
   - ecoute l'activité (evts des autres modules) et log dans un fichier

 - refactoring :
   - vérif hexagonal pattern ok
   - découpage en sous projets : 1 par module
   - découpage en sous projets : 1 par couche
   - donc m x c projets ?
   - systeme d'evts : comment faire pour que les evts d'un module par un autre ne necessitent pas l'import du module complet ?
     - sous projet a part contenant les evts => les evts ne doivent pas contenir d'objets métiers pour rendre la couche autonome

 - intégration de Camel

==> Propagation des evts sur le bus
- l'application possede un bus global
- a chaque modif d'objet, un evt est envoyé sur le bus
- cet evt doit etre envoyé aux autres modules
- les ihm doivent également recevoir cet evt
- les ihm sont instanciées a chaque session utilisateur
- il faut donc enregistrer chaque instance d'ihm sur le bus global
- afin de limiter les risques de leak, il est préférable de créer un bus de session
  puis d'enregistrer ce bus de session aupres du global, et ensuite d'enregistrer
  chaque ihm sur le bus de session
- cas du login : service->LoginEvent(GLOBALBUS)-->LocalDispatcher.handle->LoginEvent(LOCALBUS)-->MyUI.handle->login
- cas du logout :

=> Description de l'archi
- la couche business est celle qui contient le code métier important
- cette couche ne doit pas fuir vers les clients (ihm, autres modules...)
- les données contenues dans ces objets doivent donc etre transportées dans des DTO
- ces DTO sont echangés entre les modules. Ils doivent donc etre le plus simple possible (pas de dépendances techniques)
- l'application est coupée en 2 (CQRS) : Command et Query
- Command est la seule partie a accéder à business
- business genere des evts lors des traitements
- ces evts transportent des données sous forme de DTO (en aucun cas ne doivent contenir des refs vers les objets metiers)
- Command accede a un eventStore pour persister les evts générés par business et retrouver un agregat par id
- Command ne retourne pas de valeurs, mais notifie (envoi d'evts)
- Query manipule des DTO, et pas des objets métiers
- Query accede à un moyen de stockage (ex JPA), mais cela ne doit en aucun cas avoir un impact sur les DTO manipulés
- IHM accede a la fois a Command et Query, ainsi qu'aux DTO (et events)
- Rq : dans l'implémentation actuelle, les objets persistés par Query sont en fait les objets métier
  C'est une "bidouille" afin de gagner du temps. A voir pour la suite si c'est viable